<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `code_translator` mod in crate `wasmer_compiler_cranelift`."><meta name="keywords" content="rust, rustlang, rust-lang, code_translator"><title>wasmer_compiler_cranelift::translator::code_translator - Rust</title><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled ><script id="default-settings"></script><script src="../../../storage.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../../wasmer_compiler_cranelift/index.html'><div class='logo-container rust-logo'><img src='../../../rust-logo.png' alt='logo'></div></a><p class="location">Module code_translator</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#functions">Functions</a></li></ul></div><p class="location"><a href="../../index.html">wasmer_compiler_cranelift</a>::<wbr><a href="../index.html">translator</a></p><div id="sidebar-vars" data-name="code_translator" data-ty="mod" data-relpath="../"></div><script defer src="../sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../../settings.html"><img src="../../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../../index.html">wasmer_compiler_cranelift</a>::<wbr><a href="../index.html">translator</a>::<wbr><a class="mod" href="">code_translator</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../../src/wasmer_compiler_cranelift/translator/code_translator.rs.html#4-2982" title="goto source code">[src]</a></span></h1><div class="docblock"><p>This module contains the bulk of the interesting code performing the translation between
WebAssembly bytecode and Cranelift IR.</p>
<p>The translation is done in one pass, opcode by opcode. Two main data structures are used during
code translations: the value stack and the control stack. The value stack mimics the execution
of the WebAssembly stack machine: each instruction result is pushed onto the stack and
instruction arguments are popped off the stack. Similarly, when encountering a control flow
block, it is pushed onto the control stack and popped off when encountering the corresponding
<code>End</code>.</p>
<p>Another data structure, the translation state, records information concerning unreachable code
status and about if inserting a return at the end of the function is necessary.</p>
<p>Some of the WebAssembly instructions need information about the environment for which they
are being translated:</p>
<ul>
<li>the loads and stores need the memory base address;</li>
<li>the <code>get_global</code> and <code>set_global</code> instructions depend on how the globals are implemented;</li>
<li><code>memory.size</code> and <code>memory.grow</code> are runtime functions;</li>
<li><code>call_indirect</code> has to translate the function index into the address of where this
is;</li>
</ul>
<p>That is why <code>translate_function_body</code> takes an object having the <code>WasmRuntime</code> trait as
argument.</p>
<p>There is extra complexity associated with translation of 128-bit SIMD instructions.
Wasm only considers there to be a single 128-bit vector type.  But CLIF's type system
distinguishes different lane configurations, so considers 8X16, 16X8, 32X4 and 64X2 to be
different types.  The result is that, in wasm, it's perfectly OK to take the output of (eg)
an <code>add.16x8</code> and use that as an operand of a <code>sub.32x4</code>, without using any cast.  But when
translated into CLIF, that will cause a verifier error due to the apparent type mismatch.</p>
<p>This file works around that problem by liberally inserting <code>bitcast</code> instructions in many
places -- mostly, before the use of vector values, either as arguments to CLIF instructions
or as block actual parameters.  These are no-op casts which nevertheless have different
input and output types, and are used (mostly) to &quot;convert&quot; 16X8, 32X4 and 64X2-typed vectors
to the &quot;canonical&quot; type, 8X16.  Hence the functions <code>optionally_bitcast_vector</code>,
<code>bitcast_arguments</code>, <code>pop*_with_bitcast</code>, <code>canonicalise_then_jump</code>,
<code>canonicalise_then_br{z,nz}</code>, <code>is_non_canonical_v128</code> and <code>canonicalise_v128_values</code>.
Note that the <code>bitcast*</code> functions are occasionally used to convert to some type other than
8X16, but the <code>canonicalise*</code> functions always convert to type 8X16.</p>
<p>Be careful when adding support for new vector instructions.  And when adding new jumps, even
if they are apparently don't have any connection to vectors.  Never generate any kind of
(inter-block) jump directly.  Instead use <code>canonicalise_then_jump</code> and
<code>canonicalise_then_br{z,nz}</code>.</p>
<p>The use of bitcasts is ugly and inefficient, but currently unavoidable:</p>
<ul>
<li>
<p>they make the logic in this file fragile: miss out a bitcast for any reason, and there is
the risk of the system failing in the verifier.  At least for debug builds.</p>
</li>
<li>
<p>in the new backends, they potentially interfere with pattern matching on CLIF -- the
patterns need to take into account the presence of bitcast nodes.</p>
</li>
<li>
<p>in the new backends, they get translated into machine-level vector-register-copy
instructions, none of which are actually necessary.  We then depend on the register
allocator to coalesce them all out.</p>
</li>
<li>
<p>they increase the total number of CLIF nodes that have to be processed, hence slowing down
the compilation pipeline.  Also, the extra coalescing work generates a slowdown.</p>
</li>
</ul>
<p>A better solution which would avoid all four problems would be to remove the 8X16, 16X8,
32X4 and 64X2 types from CLIF and instead have a single V128 type.</p>
<p>For further background see also:
<a href="https://github.com/bytecodealliance/wasmtime/issues/1147">https://github.com/bytecodealliance/wasmtime/issues/1147</a>
(&quot;Too many raw_bitcasts in SIMD code&quot;)
<a href="https://github.com/bytecodealliance/cranelift/pull/1251">https://github.com/bytecodealliance/cranelift/pull/1251</a>
(&quot;Add X128 type to represent WebAssembly's V128 type&quot;)
<a href="https://github.com/bytecodealliance/cranelift/pull/1236">https://github.com/bytecodealliance/cranelift/pull/1236</a>
(&quot;Relax verification to allow I8X16 to act as a default vector type&quot;)</p>
</div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<table><tr class="module-item"><td><a class="fn" href="fn.bitcast_arguments.html" title="wasmer_compiler_cranelift::translator::code_translator::bitcast_arguments fn">bitcast_arguments</a></td><td class="docblock-short"><p>A helper for bitcasting a sequence of values (e.g. function arguments). If a value is a
vector type that does not match its expected type, this will modify the value in place to point
to the result of a <code>raw_bitcast</code>. This conversion is necessary to translate Wasm code that
uses <code>V128</code> as function parameters (or implicitly in block parameters) and still use specific
CLIF types (e.g. <code>I32X4</code>) in the function body.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.canonicalise_then_brnz.html" title="wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_brnz fn">canonicalise_then_brnz</a></td><td class="docblock-short"><p>The same but for a <code>brnz</code> instruction.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.canonicalise_then_brz.html" title="wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_brz fn">canonicalise_then_brz</a></td><td class="docblock-short"><p>The same but for a <code>brz</code> instruction.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.canonicalise_then_jump.html" title="wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_jump fn">canonicalise_then_jump</a></td><td class="docblock-short"><p>Generate a <code>jump</code> instruction, but first cast all 128-bit vector values to I8X16 if they
don't have that type.  This is done in somewhat roundabout way so as to ensure that we
almost never have to do any heap allocation.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.canonicalise_v128_values.html" title="wasmer_compiler_cranelift::translator::code_translator::canonicalise_v128_values fn">canonicalise_v128_values</a></td><td class="docblock-short"><p>Cast to I8X16, any vector values in <code>values</code> that are of &quot;non-canonical&quot; type (meaning, not
I8X16), and return them in a slice.  A pre-scan is made to determine whether any casts are
actually necessary, and if not, the original slice is returned.  Otherwise the cast values
are returned in a slice that belongs to the caller-supplied <code>SmallVec</code>.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.finalise_atomic_mem_addr.html" title="wasmer_compiler_cranelift::translator::code_translator::finalise_atomic_mem_addr fn">finalise_atomic_mem_addr</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.fold_atomic_mem_addr.html" title="wasmer_compiler_cranelift::translator::code_translator::fold_atomic_mem_addr fn">fold_atomic_mem_addr</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.get_heap_addr.html" title="wasmer_compiler_cranelift::translator::code_translator::get_heap_addr fn">get_heap_addr</a></td><td class="docblock-short"><p>Get the address+offset to use for a heap access.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.is_non_canonical_v128.html" title="wasmer_compiler_cranelift::translator::code_translator::is_non_canonical_v128 fn">is_non_canonical_v128</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.mem_op_size.html" title="wasmer_compiler_cranelift::translator::code_translator::mem_op_size fn">mem_op_size</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.optionally_bitcast_vector.html" title="wasmer_compiler_cranelift::translator::code_translator::optionally_bitcast_vector fn">optionally_bitcast_vector</a></td><td class="docblock-short"><p>Some SIMD operations only operate on I8X16 in CLIF; this will convert them to that type by
adding a raw_bitcast if necessary.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.pop1_with_bitcast.html" title="wasmer_compiler_cranelift::translator::code_translator::pop1_with_bitcast fn">pop1_with_bitcast</a></td><td class="docblock-short"><p>A helper for popping and bitcasting a single value; since SIMD values can lose their type by
using v128 (i.e. CLIF's I8x16) we must re-type the values using a bitcast to avoid CLIF
typing issues.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.pop2_with_bitcast.html" title="wasmer_compiler_cranelift::translator::code_translator::pop2_with_bitcast fn">pop2_with_bitcast</a></td><td class="docblock-short"><p>A helper for popping and bitcasting two values; since SIMD values can lose their type by
using v128 (i.e. CLIF's I8x16) we must re-type the values using a bitcast to avoid CLIF
typing issues.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.prepare_load.html" title="wasmer_compiler_cranelift::translator::code_translator::prepare_load fn">prepare_load</a></td><td class="docblock-short"><p>Prepare for a load; factors out common functionality between load and load_extend operations.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_atomic_cas.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_atomic_cas fn">translate_atomic_cas</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_atomic_load.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_atomic_load fn">translate_atomic_load</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_atomic_rmw.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_atomic_rmw fn">translate_atomic_rmw</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_atomic_store.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_atomic_store fn">translate_atomic_store</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_br_if.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_br_if fn">translate_br_if</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_br_if_args.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_br_if_args fn">translate_br_if_args</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_fcmp.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_fcmp fn">translate_fcmp</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_icmp.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_icmp fn">translate_icmp</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_load.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_load fn">translate_load</a></td><td class="docblock-short"><p>Translate a load instruction.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_operator.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_operator fn">translate_operator</a></td><td class="docblock-short"><p>Translates wasm operators into Cranelift IR instructions. Returns <code>true</code> if it inserted
a return.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_store.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_store fn">translate_store</a></td><td class="docblock-short"><p>Translate a store instruction.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_unreachable_operator.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_unreachable_operator fn">translate_unreachable_operator</a></td><td class="docblock-short"><p>Deals with a Wasm instruction located in an unreachable portion of the code. Most of them
are dropped but special ones like <code>End</code> or <code>Else</code> signal the potential end of the unreachable
portion so the translation state must be updated accordingly.</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_vector_fcmp.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_vector_fcmp fn">translate_vector_fcmp</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.translate_vector_icmp.html" title="wasmer_compiler_cranelift::translator::code_translator::translate_vector_icmp fn">translate_vector_icmp</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="fn" href="fn.type_of.html" title="wasmer_compiler_cranelift::translator::code_translator::type_of fn">type_of</a></td><td class="docblock-short"><p>Determine the returned value type of a WebAssembly operator</p>
</td></tr><tr class="module-item"><td><a class="fn" href="fn.wasm_param_types.html" title="wasmer_compiler_cranelift::translator::code_translator::wasm_param_types fn">wasm_param_types</a></td><td class="docblock-short"><p>A helper to extract all the <code>Type</code> listings of each variable in <code>params</code>
for only parameters the return true for <code>is_wasm</code>, typically paired with
<code>is_wasm_return</code> or <code>is_wasm_parameter</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="wasmer_compiler_cranelift"></div>
    <script src="../../../main.js"></script><script defer src="../../../search-index.js"></script></body></html>